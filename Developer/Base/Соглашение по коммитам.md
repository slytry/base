---
aliases: как писать коммиты
tags: 
date created: Wednesday, March 30th 2022, 5:18:57 pm
date modified: Thursday, March 31st 2022, 11:49:13 am
title: Conventional Commits 1.0.0
---
>Слова «MUST», «MUST NOT», «REQUIRED», «SHALL», «MAY» и «OPTIONAL» в данном документе должны интерпретироваться как в [RFC 2119](https://www.ietf.org/rfc/rfc2119.txt).

# Conventional Commits 1.0.0

Набор правил для создания понятной истории коммитов. Данные правила согласуются с методикой ведения версий SemVer

- [[Специфификация ]]
- [[Описание коммита]]
- [[История использования коммитов]]

### Шаблон коммита

```bash

<type>(<scope>): <subject>
<BLANK LINE>
<body>
<BLANK LINE>
<footer>

---

<тип>(<необязательный контекст>): <описание>


<необязательное тело>


<необязательная(ые) сноска(и)>
```

### Коммиты различаются по типам:

**Основные**

1. **fix:** коммит _типа_ `fix` исправляет баг в коде (соответствует [[Семантическое Версионирование 2.0.0#PATCH|`PATCH`]] в Cемантическом Версионировании).
2. **feat:** коммит _типа_ `feat` добавляет новую функцию в ваш код (соответствует [[Семантическое Версионирование 2.0.0#MINOR|`MINOR`]] в Cемантическом Версионировании).

**Дополнительные**

- **chore (maintain)**
- **build**: Changes that affect the build system or external dependencies (example scopes: gulp, broccoli, npm)
- **ci**: Changes to our CI configuration files and scripts (example scopes: Travis, Circle, BrowserStack, SauceLabs)
- **docs**: Documentation only changes
- **perf**: A code change that improves performance
- **refactor**: A code change that neither fixes a bug nor adds a feature
- **style**: Changes that do not affect the meaning of the code (white-space, formatting, missing semi-colons, etc)
- **test**: Adding missing tests or correcting existing tests
- **improvement**	

### Контекст

 _Контекст_ может быть добавлен к _типу_ коммита, чтобы предоставить дополнительную контекстную информацию; она содержится в скобках. Например, `feat(parser): add ability to parse arrays`.
 _Контекст_ должен (MUST) быть существительным, заключённым в круглые скобки, описывающий часть кодовой базы, которую затронул коммит.
 
 Возможный список контекстов-  
 
 - **animations**
- **common**
- **compiler**
- **compiler-cli**
- **core**
- **elements**
- **forms**
- **http**
- **language-service**
- **platform-browser**
- **platform-browser-dynamic**
- **platform-server**
- **platform-webworker**
- **platform-webworker-dynamic**
- **router**
- **service-worker**
- **upgrade**


### Cноски

 >В одной или нескольких _сносках_ может (MAY) быть одна пустая строка после _тела_. Каждая _сноска_ должна (MUST) состоять из токена слова, за которым следует разделитель `:<пробел>` или `<пробел>#`, за которым следует строковое значение (основано на [git trailer format](https://git-scm.com/docs/git-interpret-trailers)).

>Токен _сноски_ должен (MUST) использовать `-` вместо пробельных символов. Например, `Acked-by` (это помогает отличить раздел _сноски_ от его _тела_, состоящего из нескольких абзацев). Исключение составляет `BREAKING CHANGE`, которое может (MAY) также использоваться как токен.

> Если критические изменения находятся в _типе_ или _контексте_, то они должны (MUST) быть обозначены восклицательным знаком (`!`), непосредственно перед двоеточием (`:`). Если используется восклицательный знак (`!`), то `BREAKING CHANGE` может (MAY) быть опущен в _сноске_, а _описание_ коммита должно (SHALL) использоваться для описания критического изменения.

1. **BREAKING CHANGE:** коммит, который имеет _сноску_ `BREAKING CHANGE` или коммит, заканчивающийся восклицательным знаком (`!`) после _типа_ или _контекста_, вводящий изменение(я), нарушающие обратную совместимость (соответствует [[Семантическое Версионирование 2.0.0#MAJOR|`MAJOR`]] в Cемантическом Версионировании). `BREAKING CHANGE` может быть частью коммита любого _типа_.
2. **Closes** сноска для обозначение соответствующей задачи

Что еще может быть в сноске см. [тут](https://docs.github.com/en/issues/tracking-your-work-with-issues/linking-a-pull-request-to-an-issue)

### Примеры

Сообщение коммита с _описанием_ и _сноской_ `BREAKING CHANGE`

```bash
feat: allow provided config object to extend other configs

BREAKING CHANGE: `extends` key in config file is now used for extending other config files
```

**Сообщение коммита с `!` для привлечения внимания к `BREAKING CHANGE`**

```bash
feat!: send an email to the customer when a product is shipped
```

```bash
feat(api)!: send an email to the customer when a product is shipped
```

**Сообщение коммита вместе с `!` и _сноской_ `BREAKING CHANGE`**

```bash
chore!: drop support for Node 6

BREAKING CHANGE: use JavaScript features not available in Node 6.
```

**Сообщение коммита с _телом_ из нескольких абзацев и несколькими _сносками_**

```
fix: prevent racing of requests

Introduce a request id and a reference to latest request. Dismiss
incoming responses other than from latest request.

Remove timeouts which were used to mitigate the racing issue but are
obsolete now.

Reviewed-by: Z
Refs: #123
```

##   FAQ

###   Как это связано с Семантическим Версионированием?

Коммиты _типа_ `fix` должны быть переведены в выпуски `PATCH`, `feat` — в `MINOR`, `BREAKING CHANGE`, независимо от _типа_, — в `MAJOR`.

### Зачем использовать «Соглашение о коммитах»

- Автоматическое создание списков изменения.
- Автоматическое определение семантического повышения версии (на основе _типов_ совершённых коммитов).
- Информирование товарищей по команде, общественности и других заинтересованных сторон о характере изменений.
- Запуск процессов сборки и публикации.
- Упростите людям участие в ваших проектах, позволив им изучить более структурированную историю коммитов.

###   Как мне поступать с сообщениями коммитов на начальном этапе разработки?

Мы рекомендуем действовать так, как если бы вы уже выпустили продукт. Обычно _кто-то_, даже если это ваши коллеги-разработчики программного обеспечения, использует ваше программное обеспечение. Они захотят знать, что исправлено, что ломается и т. д.

###   Как «Соглашение о коммитах» обрабатывает отмену коммитов?

Отмена изменений кода может быть сложным:

- Вы отменяете изменения нескольких коммитов?
- Если вы отмените изменения новых функций, должен ли следующий выпуск быть патчем?

«Соглашение о коммитах» не делает явных попыток определить поведение отмены изменений. Вместо этого мы оставляем авторам инструментов использовать гибкость _типов_ и _сносок_ для разработки своей логики для обработки отмены изменений.

Одна из рекомендаций — использовать _тип_ `revert` и _сноску_, которая ссылается на отменяемые хэш-суммы коммитов. Например:

```
revert: let us never again speak of the noodle incident

Refs: 676104e, a215868
```

---

###### Citation

- [Автоматическая проврка коммитов](https://commitlint.js.org/#/reference-rules)
- [Соглашение о коммитах](https://www.conventionalcommits.org/ru/v1.0.0-beta.2/)
- [Keep a CHANGELOG](https://keepachangelog.com/en/0.3.0/)

Советы от ангуляра

- [AngularJS Git Commit Message Conventions](https://docs.google.com/document/d/1QrDFcIiPjSLDn3EL15IJygNPiHORgU1_OOAqWjiDU5Y/edit#) - Хорий пример коммитов здорового человека
- https://github.com/angular/angular/blob/22b96b9/CONTRIBUTING.md#-commit-message-guidelines
