---
aliases: null
date updated: 2022-01-13 15:09
---

Обычный синтаксис создания объекта (через фигурные скобки) может создать только один объект. Когда нам надо создать много однотипных объектов можно использовать функцию-конструктор и оператор "new".

### Функция-конструктор

Технически функцию конструктор это обычная функция. Но есть два соглашения.

1. Такая ф-я именуется с большой буквы
2. Это функция используется только через оператор "new".

###### Пример

```js
function User(name) {
  this.name = name;
  this.isAdmin = false;
}

let user = new User("Jack");

alert(user.name); // Jack
alert(user.isAdmin); // false`
```

Когда функция вызывается, происходит это:

1. Создается новый пустой объект и он присваивается this.
2. Выполняется код ф. Обычно он модифицирует this, добавляет туда новые свойства
3. Возвращает значения this.

Другими словами, вызов `new User(...)` делает примерно вот что:

```js
function User(name) {
 // this = {};  (неявно)

  // добавляет свойства к this
  this.name = name;
  this.isAdmin = false;

 // return this;  (неявно)
}
```

То есть, результат вызова `new User("Вася")` – это тот же объект, что и:

```js
let user = {
  name: "Вася",
  isAdmin: false
};
```

Теперь, когда нам необходимо будет создать других пользователей, мы можем использовать `new User("Маша")`, `new User("Даша")` и т.д. Данная конструкция гораздо удобнее и читабельнее, чем каждый раз создавать литерал объекта. Это и является основной целью конструкторов – удобное повторное создание однотипных объектов.

> Любая ф-я может быть вызванная через new, и будет создан новый объект.  This будет этим объектом и так далее.

> Можно обернуть  код по созданию нового объекта в функцию-конструктор вот так:
>
> ```js
> let user = new function() {
> ```

this.name = "Вася";
this.isAdmin = false;
// ...другой код для создания пользователя
// возможна любая сложная логика и выражения
// локальные переменные и т. д.
};

> ```
> такой метод создания позволяет инкапсулировать код, который создаёт отдельный объект, но без возможности его повторного использования. Функция один раз вызовется и нигде не сохраниться.
> ```

### Проверка на вызов в режиме конструктора: new.target

Используя специальное свойство `new.target` внутри функции, мы можем проверить, вызвана ли функция при помощи оператора `new` или без него.
Используя специальное свойство `new.target` внутри функции, мы можем проверить, вызвана ли функция при помощи оператора `new` или без него.

```js
function User() {
  alert(new.target);
}

// без "new":
User(); // undefined

// с "new":
new User(); // function User { ... }
```

Можно проверять как задана ф-я. Если Ф-и конструктор не правильно вызвали то она может сама себя перевызвать правильно. Но это не очень хорошая практика, так как отсутствие `new` может ввести в заблуждение. С оператором `new` мы точно знаем, что в итоге будет создан новый объект.

### Возврат значения из конструктора return

Обычно конструкторы ничего не возвращают явно. Их задача – записать все необходимое в `this`, который в итоге станет результатом.

Но если `return` всё же есть, то применяется простое правило:

- При вызове `return` с объектом, будет возвращён объект, а не `this`.
- При вызове `return` с примитивным значением, примитивное значение будет отброшено.

Другими словами, `return` с объектом возвращает объект, в любом другом случае конструктор вернёт `this`.

Но обычно ф-я-кон-р ничего не возвращает.

### Создание методов в конструкторе

Так же можно создавать методы

```js
function User(name) {
  this.name = name;

  this.sayHi = function() {
    alert( "Меня зовут: " + this.name );
  };
}

let vasya = new User("Вася");

vasya.sayHi(); // Меня зовут: Вася

/*
vasya = {
   name: "Вася",
   sayHi: function() { ... }
}
*/
```

### Итого

- Функции-конструкторы или просто конструкторы являются обычными функциями, именовать которые следует с заглавной буквы.
- Конструкторы следует вызывать при помощи оператора new. Такой вызов создаёт пустой this в начале выполнения и возвращает заполненный в конце.

JavaScript предоставляет функции-конструкторы для множества встроенных объектов языка: например, `Date`, `Set` и других, которые нам ещё предстоит изучить.

> Данная информация необходима нам для дальнейшего изучения типов данных и функций. Как только мы с ними разберёмся, мы вернёмся к объектам для более детального изучения в главах Прототипы, наследование и Классы.

---

###### Citation

<https://learn.javascript.ru/constructor-new>
Date: 2021-11-08T15:50
