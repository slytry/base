---
aliases: null
date created: 2022-01-13 18:02
date updated: 2022-01-14 13:19
---

Некоторые операции в объектами требуют предварительного преобразования в примитивный тип. Например:

- сложение объектов
- вывод содержимого объекта
- сравнение
- и тд...

### Преобразование к примитивам

Все объекты в логическом контексте являются `true`. Существуют лишь их численные и строковые преобразования.

Существуют три варианта преобразований:

1. "string"
   Для преобразования объекта к строке, когда операция ожидает получить строку, например `alert`
2. "number"
   Для преобразования объекта к числу, в случае математических операций.
3. "default"
   Происходит редко, когда оператор «не уверен», какой тип ожидать.
   Например, бинарный плюс `+` может работать с обоими типами: строками (объединять их) и числами (складывать). Таким образом, и те, и другие будут вычисляться.
   На практике все встроенные объекты, исключая `Date` (мы познакомимся с ним чуть позже), реализуют `"default"` преобразования тем же способом, что и `"number"`

**В процессе преобразования движок JavaScript пытается найти и вызвать три следующих метода объекта:**

1. Вызывает `obj[Symbol.toPrimitive](hint)` – метод с символьным ключом `Symbol.toPrimitive` (системный символ), если такой метод существует, и передаёт ему хинт.
2. Иначе, если хинт равен `"string"`
   - пытается вызвать `obj.toString()`, а если его нет, то `obj.valueOf()`, если он существует.
3. В случае, если хинт равен `"number"` или `"default"`
   - пытается вызвать `obj.valueOf()`, а если его нет, то `obj.toString()`, если он существует.

### Symbol.toPrimitive

Начнём с универсального подхода – символа `Symbol.toPrimitive`: метод с таким названием (если есть) используется для всех преобразований:

```js
let user = {
  name: "John",
  money: 1000,

  [Symbol.toPrimitive](hint) {
    alert(`hint: ${hint}`);
    return hint == "string" ? `{name: "${this.name}"}` : this.money;
  }
};

// демонстрация результатов преобразований:
alert(user); // hint: string -> {name: "John"}
alert(+user); // hint: number -> 1000
alert(user + 500); // hint: default -> 1500
```

`user` преобразовывается либо в информативную читаемую строку, либо в денежный счёт в зависимости от значения хинта. Единственный метод `user[Symbol.toPrimitive]` смог обработать все случаи преобразований.

### Методы toString/valueOf

Методы `toString` и `valueOf` берут своё начало с древних времён. Это не символы, так как в то время символов ещё не существовало, а просто обычные методы объектов со строковыми именами. Они предоставляют «устаревший» способ реализации преобразований объектов.

Если нет метода `Symbol.toPrimitive`, движок JavaScript пытается найти эти методы и вызвать их следующим образом:

- `toString -> valueOf` для хинта со значением «string».
- `valueOf -> toString` – в ином случае.

```js
let user = {
  name: "John",
  money: 1000,

  // для хинта равного "string"
  toString() {
    return `{name: "${this.name}"}`;
  },

  // для хинта равного "number" или "default"
  valueOf() {
    return this.money;
  }

};

alert(user); // toString -> {name: "John"}
alert(+user); // valueOf -> 1000
alert(user + 500); // valueOf -> 1500
```

Довольно часто мы хотим описать одно «универсальное» преобразование объекта к примитиву для всех ситуаций. Для этого достаточно создать один `toString`:

```js
let user = {
  name: "John",

  toString() {
    return this.name;
  }
};

alert(user); // toString -> John
alert(user + 500); // toString -> John500
```

В отсутствие `Symbol.toPrimitive` и `valueOf`, `toString` обработает все случаи преобразований к примитивам.

### Возвращаемые типы

Важно понимать, что все описанные методы для преобразований объектов не обязаны возвращать именно требуемый «хинтом» тип примитива.

Нет обязательного требования, чтобы `toString()` возвращал именно строку, или чтобы метод `Symbol.toPrimitive` возвращал именно число для хинта «number».

**Единственное обязательное требование: методы должны возвращать примитив, а не объект.**

> По историческим причинам, если `toString` или `valueOf` вернёт объект, то ошибки не будет, но такое значение будет проигнорировано (как если бы метода вообще не существовало).
> Метод `Symbol.toPrimitive`, напротив, _обязан_ возвращать примитив, иначе будет ошибка.

### Последующие операции

Операция, инициировавшая преобразование, получает примитив и затем продолжает работу с ним, производя дальнейшие преобразования, если это необходимо.

- Математические операции, исключая бинарный плюс, преобразуют примитив к числу
- Бинарный плюс `+` в аналогичном случае сложит строки

---

###### Citation
