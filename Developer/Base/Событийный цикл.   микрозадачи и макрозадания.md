---
aliases: null
date updated: 2022-01-23 13:00
---

Поток выполнения в браузере, равно как и в Node.js, основан на _событийном цикле_.

Понимание работы событийного цикла важно для оптимизаций, иногда для правильной архитектуры.

### Событийный цикл

Идея _событийного цикла_ очень проста. Есть бесконечный цикл, в котором движок JavaScript ожидает задачи, исполняет их и снова ожидает появления новых.

Общий алгоритм движка:

1. Пока есть задачи:
   - выполнить их, начиная с самой старой
2. Бездействовать до появления новой задачи, а затем перейти к пункту 1

Может так случиться, что задача поступает, когда движок занят чем-то другим, тогда она ставится в очередь.

Очередь, которую формируют такие задачи, называют «очередью макрозадач» (macrotask queue, термин v8).
![[eventLoop.svg|700]]

Например, когда движок занят выполнением скрипта, пользователь может передвинуть мышь, тем самым вызвав появление события `mousemove`, или может истечь таймер, установленный `setTimeout`, и т.п. Эти задачи формируют очередь, как показано на иллюстрации выше.

Задачи из очереди исполняются по правилу «первым пришёл – первым ушёл». Когда браузер заканчивает выполнение скрипта, он обрабатывает событие `mousemove`, затем выполняет обработчик, заданный `setTimeout`, и так далее.

Отметим две детали:

1. Рендеринг (отрисовка страницы) никогда не происходит во время выполнения задачи движком. Не имеет значения, сколь долго выполняется задача. Изменения в DOM отрисовываются только после того, как задача выполнена.
2. Если задача выполняется очень долго, то браузер не может выполнять другие задачи, обрабатывать пользовательские события, поэтому спустя некоторое время браузер предлагает «убить» долго выполняющуюся задачу. Такое возможно, когда в скрипте много сложных вычислений или ошибка, ведущая к бесконечному циклу.

### Пример 1: разбиение «тяжёлой» задачи.

Допустим, у нас есть задача, требующая значительных ресурсов процессора.

Оставная идея это разбиение на более простые кусочки с помощью setTimeout. Это не дает браузеру зависнуть на время всего выполнения сложной задачи.

Подробности смотреть в источнике.

### Пример 2: индикация прогресса

Разбиение задачи на кусочки позволяет выволдить промежуточные значения. Страндартное поведение это отрисовать все сразу

Подробности смотреть в источнике.

### Пример 3: делаем что-нибудь после события

Можно сделать отложенную обработку события.

Подробности смотреть в источнике.

### Макрозадачи и Микрозадачи

Помимо _макрозадач_, описанных в этой части, существуют _микрозадачи_, упомянутые в главе [Микрозадачи](https://learn.javascript.ru/microtask-queue).

Микрозадачи приходят только из кода. Обычно они создаются промисами: выполнение обработчика `.then/catch/finally` становится микрозадачей. Микрозадачи также используются «под капотом» `await`, т.к. это форма обработки промиса.

Также есть специальная функция `queueMicrotask(func)`, которая помещает `func` в очередь микрозадач.

**Сразу после каждой _макрозадачи_ движок исполняет все задачи из очереди _микрозадач_ перед тем, как выполнить следующую макрозадачу или отобразить изменения на странице, или сделать что-то ещё.**
![[eventLoop-full.svg|700]]

**Все микрозадачи завершаются до обработки каких-либо событий или рендеринга, или перехода к другой макрозадаче.**

Это важно, так как гарантирует, что общее окружение остаётся одним и тем же между микрозадачами – не изменены координаты мыши, не получены новые данные по сети и т.п.

Если мы хотим запустить функцию асинхронно (после текущего кода), но до отображения изменений и до новых событий, то можем запланировать это через `queueMicrotask`.

### Web Workers

Для длительных тяжёлых вычислений, которые не должны блокировать событийный цикл, мы можем использовать [Web Workers](https://html.spec.whatwg.org/multipage/workers.html).

Это способ исполнить код в другом, параллельном потоке.

Web Workers могут обмениваться сообщениями с основным процессом, но они имеют свои переменные и свой событийный цикл.

Web Workers не имеют доступа к DOM, поэтому основное их применение – вычисления. Они позволяют задействовать несколько ядер процессора одновременно.

### Старые записи

По сути это реализация асинхронности в браузере. Зная ее тонкости мы может избежать некоторых фатальный ошибок кода, и лучше понимать работу кода.

Есть три сущности :

- stack - там где выполняется код
- webapis - там где код ждет
- tast queue - очередь задач

Синхронный код попадает сразу на выполнение.
Асинхронный код попадает в веб апи → ждет → переходит в очередь → выполняется.
**Случаи**

1. Код очень долго ждал, но не не смог получить ответ. Это нормально. Он не попадет просто в очередь
2. Есть очень затратная задача. Например сложная обработка данных. Она может долно находиться на выполненип в stack и при этом другая ассинхронная задача готова отработать, и стоит в очереди, но она не может выполнится. Когда мы ожидаем чего оно просто не происходит, stack занят. (В таких случаях надо разбиавть задачу на много мелких, это известаня проблемма много поточности, пока это явно не мой уровень)
3. Если запустить ф. timeout со значением 0, но она не отработает как синхронный код. Она попадет в конец очереди. Так первое действие будет — запись в webapis, потом он увидит что там ноль, и поставит в очередь, но в это время остальной код (синхронный) уже начал выполняться. А второе, js по умолчанию в крысу подставляет 4мс, чтобы обеспечить совместимость браузеров.

---

###### Citation

[Event loop](http://latentflip.com/loupe/?code=JC5vbignYnV0dG9uJywgJ2NsaWNrJywgZnVuY3Rpb24gb25DbGljaygpIHsKICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gdGltZXIoKSB7CiAgICAgICAgY29uc29sZS5sb2coJ1lvdSBjbGlja2VkIHRoZSBidXR0b24hJyk7ICAgIAogICAgfSwgMjAwMCk7Cn0pOwoKY29uc29sZS5sb2coIkhpISIpOwoKc2V0VGltZW91dChmdW5jdGlvbiB0aW1lb3V0KCkgewogICAgY29uc29sZS5sb2coIkNsaWNrIHRoZSBidXR0b24hIik7Cn0sIDUwMDApOwoKY29uc29sZS5sb2coIldlbGNvbWUgdG8gbG91cGUuIik7!!!PGJ1dHRvbj5DbGljayBtZSE8L2J1dHRvbj4%3D)
<https://javascript.info/event-loop>
Date: 2021-11-17T10:53
