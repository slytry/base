---
aliases: null
date created: 2022-01-12 12:16
date updated: 2022-01-12 12:36
---

Одним из фундаментальных отличий объектов от примитивных типов данных является то, что они хранятся и копируются «по ссылке». Примитивные типы: строки, числа, логические значения – присваиваются и копируются «по значению».

Если присвоить объект другой переменной, но просто присвоится ссылка на объект. Сам объект будет в единственном экземпляре. Меняя свойства через любую скопированную переменную мы будет менять исходный объект.

### Сравнение

Операторы равенства `==` и строгого равенства `===` для объектов работают одинаково.

**Два объекта равны только в том случае, если это один и тот же объект.**
То есть два переменные с ссылками на один и тот же объект будут равны друг другу. Два пустых разные объекта уже не равны друг другу.

Для сравнений типа `obj1 > obj2` или для сравнения с примитивом `obj == 5` объекты преобразуются в примитивы, но сравнения такого рода необходимы очень редко и обычно являются результатом ошибки программиста.

### Клонирование и объединение объектов, Object.assign

Если нужно дублировать объект.
Мы создаем новый объект и перебираем свойства и копируем.

```js
let user = {
  name: "Иван",
  age: 30
};

let clone = {}; // новый пустой объект

// скопируем все свойства user в него
for (let key in user) {
  clone[key] = user[key];
}
```

Кроме того, для этих целей мы можем использовать метод [Object.assign](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/assign).

Синтаксис:

`Object.assign(dest, [src1, src2, src3...])`

- Первый аргумент `dest` — целевой объект.
- Остальные аргументы `src1, ..., srcN` (может быть столько, сколько нужно) являются исходными объектами
- Метод копирует свойства всех исходных объектов `src1, ..., srcN` в целевой объект `dest`. То есть, свойства всех перечисленных объектов, начиная со второго, копируются в первый объект.
- Возвращает объект `dest`.
- Если в целевом объекте уже есть такой ключи, то он перезапишется

Мы также можем использовать `Object.assign` для замены `for..in` на простое клонирование:
```js
let user = {
  name: "Иван",
  age: 30
};

let clone = Object.assign({}, user);
```

Такое копирование предполагает что все свойства были примитивными значениями, не имели вложенности. Это два способа делают поверхностное копирование. Вложенные объекты внутри исходного и скопированного объекта будут все еще простыми ссылками и будут ссылаться на один и тот же объект.

### Вложенное копирование (глубокое)
Чтобы исправить это, мы должны в цикле клонирования делать проверку, не является ли значение `user[key]` объектом, и если это так – скопировать и его структуру тоже. Это называется «глубокое клонирование».

Мы можем реализовать глубокое клонирование, используя рекурсию. Или, чтобы не изобретать велосипед, использовать готовую реализацию — метод [_.cloneDeep(obj)](https://lodash.com/docs#cloneDeep) из JavaScript-библиотеки [lodash](https://lodash.com/).

Вариант через JSON
`const clone = JSON.parce(JSON.stringify(obj)`

---

###### Citation
