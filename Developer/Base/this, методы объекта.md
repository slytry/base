---
aliases: null
date updated: 2022-01-20 09:38
---

ООП подразумевает что у объекта есть методы. То есть функции заданные внутри объекта.

```js
// эти объекты делают одно и то же (одинаковые методы)

user = {
  sayHi: function() {
    alert("Привет");
  }
};

// сокращённая запись выглядит лучше, не так ли?
user = {
  sayHi() { // то же самое, что и "sayHi: function()"
    alert("Привет");
  }
};
```

Эти два способа обладают тонкими различиями связанные с наследованием объектов. Но пока это не важно. В большинстве случаев сокращённый синтаксис предпочтителен.

### Ключевое слово «this» в методах

Обычно методам внутри объекта нужен доступ к свойствам объекта. Это можно сделать через `this`.
Значение `this` – это объект «перед точкой», который использовался для вызова метода.

```js
let user = {
  name: "Джон",
  age: 30,

  sayHi() {
    // this - это "текущий объект"
    alert(this.name);
  }

};

user.sayHi(); // Джон
```

Технически можно использовать имя переменной вместо `this`, но такой код будет не надежен. Может потеряться ссылка и через эту переменную, а через другую остаться, и тогда не сработает. Был бы `this`, тогда сработало.

в JS можно использовать `this` в любой ф-и. This будет заменятся при компиляции объектом через который вызывается метод. То есть одну ф-ю можно вызывать с разными объектами

```js
let user = { name: "Джон" };
let admin = { name: "Админ" };

function sayHi() {
  alert( this.name );
}

// используем одну и ту же функцию в двух объектах
user.f = sayHi;
admin.f = sayHi;

// вызовы функции, приведённые ниже, имеют разное значение this
// "this" внутри функции является ссылкой на объект, который указан "перед точкой"
user.f(); // Джон  (this == user)
admin.f(); // Админ  (this == admin)

admin['f'](); // Админ (неважен способ доступа к методу - через точку или квадратные скобки)
```

Если вызвать ф-ю без объекта в строгом режиме будет `undefined`, если нет `"use strict"` то значение замениться на глобальный объект `window` (для браузера). Такой вызов обычно является ошибкой. Если внутри ф-и есть `this` подразумевается что она будет вызвана в контексте объекта.

### Внутренняя реализация: Ссылочный тип

Из-за внутренних особенностей языка может происходить потеря контекста. Эта особенность - специальные внутренний «ссылочного типа», называемого [Reference Type](https://tc39.github.io/ecma262/#sec-reference-specification-type). На самом деле когда вызывается метод объекта через точку `obj.method()` возвращается не ф-я, а «триплет»: комбинация из трёх значений `(base, name, strict)`, где:

- `base` – это объект.
- `name` – это имя свойства объекта.
- `strict` – это режим исполнения. Является true, если действует строгий режим (`use strict`).

И тогда при компиляции может правильно замениться `this` по информации об объекта из base. Это сработает только если вызвать метод через точку. Во всех других случаях контекст будет потерян, так как работа будет напрямую с ф-й. Эту проблему можно решить с помощью ф-и bind

### У стрелочный функции нет this

Стрелочные ф-и особенные, у них нет своего контекста `this`. Значение берется из внешней «нормальной» ф-и.
Это полезно, когда мы на самом деле не хотим иметь отдельное значение `this`, а хотим брать его из внешнего контекста.

Если ф. в обработчике событий задана через function declaration (когда ф. доступна в любом месте в коде) то она имеет контекст обекта на котором сработало событие.
Если через стрелочную ф. то контекст вызова теряется (undefined), или становится window, если не strict.

### Контекст

Функция может вызываться 4-мя способами. И каждый раз будет свой контекст вызова (this)

1. Обычная функция — this = window, если не включен strict режим. Если включен - undefined.

Функция просто вызывается через круглые скобки. Тогда ее контекст зависит от использования строгого режима.

```js
use strict;
function showThis() {
  console.log(this);
}
showThis();
```

2. Мотод внутри объекта: this = объекту.

```js
const obj = {
	a: 3,
	b: 5,
	sum: function() {
		console.log(this);
	}
}
obj.sum();
```

Возвращает сам объект.

3. this  в конструкторах и классах - это новый экземпляр объекта

```js
function User(name, id) {
  this.name = name;
  this.is = id;
  this.isAdmin = false;
    this.hello = function() {
	  console.log('Hello' + this.name);
	}
}
let Jack = new User("Jack", 23);
```

4. Руное присвоение call, aplly, blind

Есть три метода для присвоении ф.и контекста.

- `fuction.apply(obj, arg)`
- `fuction.call(odj, [arg])`

Одни делают одно и тоже, разница в синтаксисе. аргументы в одном случаю пишутся с квадр. скобками, а в другом без. В одном передается массив значений, в другой список. Эти методы не создают новой функции, только передают контекст.

- `const anyFunc = thisFunc.bind(thisValue)`

У нас есть ф.и с использованием this. Эту ф. можно дублировать с одновременным присваиванием контекста. Мы задаем переменную. Этой переменно присваиваем ф.ю + `bind`. В аргументе `bind` пишем желаемое значение this.

---

###### Citation

<https://learn.javascript.ru/object-methods>
[О ключевом слове «this» языка JavaScript: особенности использования с пояснениями](https://tproger.ru/translations/javascript-this-keyword/)
Date: 2021-11-09T14:08
