---
aliases: null
date updated: 2022-01-23 14:22
date created: 2021-11-12 21:21
---

### Асинхронные функции

```js
async function f() {
  return 1;
}
```

У слова `async` один простой смысл: эта функция всегда возвращает промис. Значения других типов оборачиваются в завершившийся успешно промис автоматически.

Например, эта функция возвратит выполненный промис с результатом `1`:

```js
async function f() {
  return 1;
}

f().then(alert); // 1
```

Так что ключевое слово `async` перед функцией гарантирует, что эта функция в любом случае вернёт промис. Согласитесь, достаточно просто? Но это ещё не всё. Есть другое ключевое слово – `await`, которое можно использовать только внутри `async`-функций.

### Await

```js
// работает только внутри async–функций
let value = await promise;
```

Ключевое слово await заставит интерпретатор JavaScript ждать до тех пор, пока промис справа от await не выполнится. После чего оно вернёт его результат, и выполнение кода продолжится.

Обратите внимание, хотя `await` и заставляет JavaScript дожидаться выполнения промиса, это не отнимает ресурсов процессора. Пока промис не выполнится, JS-движок может заниматься другими задачами: выполнять прочие скрипты, обрабатывать события и т.п.

По сути, это просто «синтаксический сахар» для получения результата промиса, более наглядный, чем `promise.then`.

**Асинхронные методы классов**
Для объявления асинхронного метода достаточно написать `async` перед именем:

```js
class Waiter {
  async wait() {
    return await Promise.resolve(1);
  }
}

new Waiter()
  .wait()
  .then(alert); // 1
```

Как и в случае с асинхронными функциями, такой метод гарантированно возвращает промис, и в его теле можно использовать `await`.

### Итого

Ключевое слово `async` перед объявлением функции:

1. Обязывает её всегда возвращать промис.
2. Позволяет использовать `await` в теле этой функции.

Ключевое слово `await` перед промисом заставит JavaScript дождаться его выполнения, после чего:

1. Если промис завершается с ошибкой, будет сгенерировано исключение, как если бы на этом месте находилось `throw`.
2. Иначе вернётся результат промиса.

Вместе они предоставляют отличный каркас для написания асинхронного кода. Такой код легко и писать, и читать.

Хотя при работе с `async/await` можно обходиться без `promise.then/catch`, иногда всё-таки приходится использовать эти методы (на верхнем уровне вложенности, например). Также `await` отлично работает в сочетании с `Promise.all`, если необходимо выполнить несколько задач параллельно.

### Старые заметки
Написали fetch (асинхронный запрос без перезагрузки страницы), обернули его в функцию что бы управлять параметрами. Ретёрним результат запроса.

```
const postData = (url, data) => {
		const res = fetch(url, {
			method: 'POST',
			headers: {
					'Content-Type': 'application/json'
			},
			body: data
		});

		return res.json();
	};
```

Запрос от сервера может итди долго, а ретерн сработает сразу. Будет ошибка. Для решения этой проблеммы есть `async/await`

### async

Перед ф. пишем async  и все понимают что в этой ф. асинхронный код.
А потом пише await перед тем кодом, который надо дождаться. Эти две команды используются только парно (но если await не казать то ошибки не будет). И все, JS подождет ответа сервера.

```
const postData = async (url, data) => {
   	const res = await fetch(url, {
   		method: 'POST',
   		headers: {
   				'Content-Type': 'application/json'
   		},
   		body: data
   	});

   	return await res.json();
   };
```

Второй await перед преобразованием json  в объект есть, потому что может быть очень много информации, и сколько она будет обрабатываться неизвестно.

---

###### Citation

<https://javascript.info/async-await>
