---
aliases: null
date created: 2022-01-20 20:41
date updated: 2022-01-21 16:37
---

_Перебираемые_ (или _итерируемые_) объекты – это концепция, которая позволяет использовать любой объект в цикле `for..of`.

Как сделать так чтобы можно было перебирать объект не являющийся массивом в в цикле `for..of`

### Symbol.iterator

Для того чтобы итеррировать объект надо добавить в объект метод с именем Symbol.iterator, специальный встроенный  `Symbol` созданный для этого.

1. Когда цикл `for..of` запускается, он вызывает этот метод один раз (или выдаёт ошибку, если метод не найден). Этот метод должен вернуть _итератор_ – объект с методом `next`.
2. Дальше `for..of` работает _только с этим возвращённым объектом_.
3. Когда `for..of` хочет получить следующее значение, он вызывает метод `next()` этого объекта.
4. Результат вызова `next()` должен иметь вид `{done: Boolean, value: any}`, где `done=true` означает, что итерация закончена, в противном случае `value` содержит очередное значение.

```js
let range = {
  from: 1,
  to: 5
};

// 1. вызов for..of сначала вызывает эту функцию
range[Symbol.iterator] = function() {

  // ...она возвращает объект итератора:
  // 2. Далее, for..of работает только с этим итератором, запрашивая у него новые значения
  return {
    current: this.from,
    last: this.to,

    // 3. next() вызывается на каждой итерации цикла for..of
    next() {
      // 4. он должен вернуть значение в виде объекта {done:.., value :...}
      if (this.current <= this.last) {
        return { done: false, value: this.current++ };
      } else {
        return { done: true };
      }
    }
  };
};

// теперь работает!
for (let num of range) {
  alert(num); // 1, затем 2, 3, 4, 5
}
```

> Бесконечные итераторы
> Можно сделать бесконечный итератор. Например, `range` будет бесконечным при `range.to = Infinity`. Или мы можем создать итерируемый объект, который генерирует бесконечную последовательность псевдослучайных чисел. Это бывает полезно.
> Метод `next` не имеет ограничений, он может возвращать всё новые и новые значения, это нормально.
> Конечно же, цикл `for..of` с таким итерируемым объектом будет бесконечным. Но мы всегда можем прервать его, используя `break`.

### Строка – перебираемый объект

Для массивов и строк метод итерратора уже встроен.
Для строки `for..of` перебирает символы, работает корректно даже с суррогатными парами

### Явный вызов итератора

Итераторы можно использовать явно

```js
let str = "Hello";

// делает то же самое, что и
// for (let char of str) alert(char);

let iterator = str[Symbol.iterator]();

while (true) {
  let result = iterator.next();
  if (result.done) break;
  alert(result.value); // выводит символы один за другим
}
```

Такое редко бывает необходимо, но это даёт нам больше контроля над процессом, чем `for..of`. Например, мы можем разбить процесс итерации на части: перебрать немного элементов, затем остановиться, сделать что-то ещё и потом продолжить.

### Итерируемые объекты и псевдомассивы

Есть два официальных термина, которые очень похожи, но в то же время сильно различаются. Важный термина.

- _Итерируемые объекты_ – это объекты, которые реализуют метод `Symbol.iterator`, как было описано выше.
- _Псевдомассивы_ – это объекты, у которых есть индексы и свойство `length`, то есть, они выглядят как массивы.

Например, строки итерируемы (для них работает `for..of`) и являются псевдомассивами (они индексированы и есть `length`).

Но итерируемый объект может не быть псевдомассивом. И наоборот: псевдомассив может не быть итерируемым.

Итерируемые объекты, и псевдомассивы - это не массивы, у нах нет всего арсенала удобных методов, как у массива.

### Array.from

Есть универсальный метод [Array.from](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array/from), который принимает итерируемый объект или псевдомассив и делает из него «настоящий» `Array`. После этого мы уже можем использовать методы массивов.

```js
let arrayLike = {
  0: "Hello",
  1: "World",
  length: 2
};

let arr = Array.from(arrayLike); // (*)
alert(arr.pop()); // World (метод работает)
```

`Array.from` в строке `(*)` принимает объект, проверяет, является ли он итерируемым объектом или псевдомассивом, затем создаёт новый массив и копирует туда все элементы.

```js
Array.from(obj[, mapFn, thisArg])
```
Необязательный второй аргумент может быть функцией, которая будет применена к каждому элементу перед добавлением в массив, а `thisArg` позволяет установить `this` для этой функции.


---

###### Citation
