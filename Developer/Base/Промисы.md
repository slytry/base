---
aliases: null
date updated: 2022-01-22 18:52
---

Обещания. С ним приятно работать с асинхроными функциями. (Таймауты и запросы на сервер это асинхронность. И много друго кода в JS).

Очень наглядно можно предствить два кода. Одному надо время чтобы выполнеться, другой ждет выполнения,  а `Promise` специальный объект связывающий эти два кода.

```js
let promise = new Promise(function(resolve, reject) {
  // функция-исполнитель (executor)
});
```

Функция, переданная в конструкцию `new Promise`, называется _исполнитель_ (executor). Когда `Promise` создаётся, она запускается автоматически. Она должна содержать «создающий» код, который когда-нибудь создаст результат.

Её аргументы `resolve` и `reject` – это колбэки, которые предоставляет сам JavaScript. Наш код – только внутри исполнителя.

Когда он получает результат, сейчас или позже – не важно, он должен вызвать один из этих колбэков:

- `resolve(value)` — если работа завершилась успешно, с результатом `value`.
- `reject(error)` — если произошла ошибка, `error` – объект ошибки.

У объекта `promise`, возвращаемого конструктором `new Promise`, есть внутренние свойства:

- `state` («состояние») — вначале `"pending"` («ожидание»), потом меняется на `"fulfilled"` («выполнено успешно») при вызове `resolve` или на `"rejected"` («выполнено с ошибкой») при вызове `reject`.
- `result` («результат») — вначале `undefined`, далее изменяется на `value` при вызове `resolve(value)` или на `error` при вызове `reject(error)`.

![[promise-resolve-reject.svg]]

Свойства `state` и `result` – это внутренние свойства объекта `Promise` и мы не имеем к ним прямого доступа. Их не используют для работы с просисами.

Исполнитель выполняет задачу (что-то, что обычно требует времени), затем вызывает `resolve` или `reject`, чтобы изменить состояние соответствующего `Promise`.

Должно быть вызрано что-то одно: `resolve` или `reject`. Сотояние промиса меняется один раз. Все последующие вызовы `resolve` и `reject` будут проигнорированы.
Так же функция `resolve`/`reject` ожидает только один аргумент (или ни одного). Все дополнительные аргументы будут проигнорированы.

**Вызывайть `reject` с объектом `Error`**

В случае, если что-то пошло не так, надо вызвать `reject`. Это можно сделать с аргументом любого типа (как и `resolve`), но рекомендуется использовать объект `Error` (или унаследованный от него).

**Вызов `resolve`/`reject` сразу**

Обычно исполнитель делает что-то асинхронное и после этого вызывает `resolve`/`reject`, то есть через какое-то время. Но это не обязательно, `resolve` или `reject` могут быть вызваны сразу. Это может случиться, например, когда мы начали выполнять какую-то задачу, но тут же увидели, что ранее её уже выполняли, и результат закеширован.

Такая ситуация нормальна. Мы сразу получим успешно завершённый `Promise`.

Так же на завершённых промисах обработчики запускаются сразу. Если промис в состоянии ожидания, обработчики в `.then/catch/finally` будут ждать его. Однако, если промис уже завершён, то обработчики выполнятся сразу.

### then, catch, finally

**then** Наиболее важный и фундаментальный метод

```js
promise.then(
  function(result) { /* обработает успешное выполнение */ },
  function(error) { /* обработает ошибку */ }
);
```

Первый аргумент метода `.then` – функция, которая выполняется, когда промис переходит в состояние «выполнен успешно», и получает результат.

Второй аргумент `.then` – функция, которая выполняется, когда промис переходит в состояние «выполнен с ошибкой», и получает ошибку.

**catch**

Если мы хотели бы только обработать ошибку, то можно использовать `null` в качестве первого аргумента: `.then(null, errorHandlingFunction)`. Или можно воспользоваться методом `.catch(errorHandlingFunction)`, который сделает то же самое:

```js
let promise = new Promise((resolve, reject) => {
  setTimeout(() => reject(new Error("Ошибка!")), 1000);
});

// .catch(f) это то же самое, что promise.then(null, f)
promise.catch(alert); // выведет "Error: Ошибка!" спустя одну секунду
```

Вызов `.catch(f)` – это сокращённый, «укороченный» вариант `.then(null, f)`.

**finally**
По аналогии с блоком `finally` из обычного `try {...} catch {...}`, у промисов также есть метод `finally`. Этот блок кода выполниться в любом случае.

`finally` хорошо подходит для очистки, например остановки индикатора загрузки, его ведь нужно остановить вне зависимости от результата.

```js
new Promise((resolve, reject) => {
  /* сделать что-то, что займёт время, и после вызвать resolve/reject */
})
  // выполнится, когда промис завершится, независимо от того, успешно или нет
  .finally(() => остановить индикатор загрузки)
  .then(result => показать результат, err => показать ошибку)
```

1. Обработчик, вызываемый из `finally`, не имеет аргументов. В `finally` мы не знаем, как был завершён промис. И это нормально, потому что обычно наша задача – выполнить «общие» завершающие процедуры.
2. Обработчик `finally` «пропускает» результат или ошибку дальше, к последующим обработчикам.
3. Последнее, но не менее значимое: вызов `.finally(f)` удобнее, чем `.then(f, f)` – не надо дублировать функции f.

---

###### Citation

<https://learn.javascript.ru/promise-basics>
